import math
from typing import Callable, List, Tuple

# Параметры алгоритма
EPSILON = 1e-5
GRID_WIDTH = 40
GRID_HEIGHT = 20


def main():
    # Целевая функция
    def f(x: List[float]) -> float:
        return x[0] ** 4 - 2 * x[0] * x[1] + x[1] ** 4 - x[0] ** 2 - x[1] ** 2

    # Начальные точки для тестирования
    initial_points = [
        [0.5, 0.5],  # Ближе к (1,1)
        [-0.5, -0.5],  # Ближе к (-1,-1)
        [0.1, 0.1]  # Близко к седловой точке (0,0)
    ]

    for i, point in enumerate(initial_points):
        print(f"\nПоиск #{i + 1} из начальной точки ({point[0]}, {point[1]})")

        # Запуск оптимизации
        result, f_value, trajectory = hooke_jeeves_search(f, point.copy(), [0.2, 0.2])

        # Вывод результатов
        print(f"Найденная точка: ({result[0]:.4f}, {result[1]:.4f})")
        print(f"Значение функции: {f_value:.4f}")
        print("Траектория поиска:")
        print_ascii_map(trajectory)


def hooke_jeeves_search(f: Callable[[List[float]], float],
                        initial_point: List[float],
                        delta: List[float]) -> Tuple[List[float], float, List[Tuple[float, float]]]:
    x = initial_point.copy()
    trajectory = [(x[0], x[1])]
    iterations = 0

    while True:
        # Исследующий поиск
        x_new = exploratory_search(f, x, delta)

        # Проверка улучшения
        if f(x_new) < f(x):
            # Поиск по образцу
            direction = [x_new[i] - x[i] for i in range(2)]
            x_accelerated = [x_new[i] + 2 * direction[i] for i in range(2)]

            if f(x_accelerated) < f(x_new):
                x = x_accelerated
            else:
                x = x_new

            trajectory.append((x[0], x[1]))
        else:
            # Уменьшаем шаг
            delta = [d / 2 for d in delta]
            if all(d < EPSILON for d in delta):
                break

        iterations += 1
        if iterations >= 100:
            break

    return x, f(x), trajectory


def exploratory_search(f: Callable[[List[float]], float], x: List[float], delta: List[float]) -> List[float]:
    x_new = x.copy()

    for i in range(2):
        original = x_new[i]
        best_value = f(x_new)

        # Пробуем +delta
        x_new[i] = original + delta[i]
        value_plus = f(x_new)

        # Пробуем -delta
        x_new[i] = original - delta[i]
        value_minus = f(x_new)

        # Выбираем наилучший вариант
        if value_plus < best_value and value_plus < value_minus:
            x_new[i] = original + delta[i]
        elif value_minus < best_value:
            x_new[i] = original - delta[i]
        else:
            x_new[i] = original

    return x_new


def print_ascii_map(trajectory: List[Tuple[float, float]],
                    width: int = GRID_WIDTH,
                    height: int = GRID_HEIGHT):
    """Выводит ASCII-карту с траекторией поиска"""
    # Диапазон координат для отображения
    x_min, x_max = -1.5, 1.5
    y_min, y_max = -1.5, 1.5

    # Создаем пустую карту
    grid = [['·' for _ in range(width)] for _ in range(height)]

    # Отмечаем стационарные точки
    points = {
        (1, 1): 'M',  # Минимум
        (-1, -1): 'M',  # Минимум
        (0, 0): 'S'  # Седловая точка
    }

    for (x, y), symbol in points.items():
        col = int((x - x_min) / (x_max - x_min) * (width - 1))
        row = int((y_max - y) / (y_max - y_min) * (height - 1))  # Инвертируем y
        if 0 <= row < height and 0 <= col < width:
            grid[row][col] = symbol

    # Отмечаем траекторию
    for i, (x, y) in enumerate(trajectory):
        col = int((x - x_min) / (x_max - x_min) * (width - 1))
        row = int((y_max - y) / (y_max - y_min) * (height - 1))
        if 0 <= row < height and 0 <= col < width:
            # Используем разные символы для разных этапов пути
            char = str(i % 10) if i < 10 else chr(ord('a') + (i - 10) % 26)
            if grid[row][col] == '·':  # Не перезаписываем стационарные точки
                grid[row][col] = char

    # Выводим карту
    print("+" + "-" * width + "+")
    for row in grid:
        print("|" + "".join(row) + "|")
    print("+" + "-" * width + "+")
    print("Легенда:")
    print("M - минимум (1,1) или (-1,-1)")
    print("S - седловая точка (0,0)")
    print("Цифры/буквы - траектория поиска (по порядку)")


if __name__ == "__main__":
    main()
