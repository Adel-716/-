import math
from typing import Callable, List

# Параметры алгоритма
EPSILON = 1e-3  # Точность поиска
GRID_SIZE = 15  # Размер сетки для визуализации
trajectory = []  # Список для хранения точек траектории

def main():
    # Новая целевая функция: f(x) = x1^4 - 2x1x2 + x2^4 - x1^2 - x2^2
    f = lambda x: x[0]**4 - 2 * x[0] * x[1] + x[1]**4 - x[0]**2 - x[1]**2

    # Набор начальных точек для тестирования (3 точки)
    initial_points = [
        [-1, -1],    # Точка в отрицательной области
        [1, 1],       # Точка в положительной области
        [0.5, 0.5]   # Точка близкая к минимуму
    ]

    # Запуск оптимизации для каждой начальной точки
    for point in initial_points:
        global trajectory
        trajectory = []  # Очищаем предыдущую траекторию
        print("\n══════════════════════════════════════")
        print(f"Начальная точка: ({point[0]}, {point[1]})")
        optimize(f, point)  # Запуск оптимизации
        print_trajectory()  # Визуализация траектории
        print("══════════════════════════════════════")

# Основной метод оптимизации (без изменений)
def optimize(f: Callable[[List[float]], float], initial_point: List[float]):
    x = initial_point.copy()
    trajectory.append(x.copy())
    delta = [0.5, 0.5]
    alpha = 2.0
    iterations = 0

    while True:
        x_new = exploratory_search(f, x, delta)

        if f(x_new) >= f(x):
            for i in range(len(delta)):
                delta[i] *= 0.5
            if delta[0] < EPSILON and delta[1] < EPSILON:
                break
        else:
            direction = [x_new[i] - x[i] for i in range(len(x))]

            x_accelerated = [x_new[i] + alpha * direction[i] for i in range(len(x))]

            if f(x_accelerated) < f(x_new):
                x = x_accelerated
            else:
                x = x_new
            trajectory.append(x.copy())
        iterations += 1

    print("\nРезультаты оптимизации:")
    print(f"Точка минимума: ({x[0]:.4f}, {x[1]:.4f})")
    print(f"Значение функции: {f(x):.4f}")
    print(f"Итераций: {iterations}")

# Метод исследующего поиска (без изменений)
def exploratory_search(f: Callable[[List[float]], float], x: List[float], delta: List[float]) -> List[float]:
    x_new = x.copy()

    for i in range(len(x)):
        original_value = x_new[i]

        x_new[i] = original_value + delta[i]
        value_plus = f(x_new)

        x_new[i] = original_value - delta[i]
        value_minus = f(x_new)

        if value_plus < f(x_new):
            x_new[i] = original_value + delta[i]
        elif value_minus < f(x_new):
            x_new[i] = original_value - delta[i]
        else:
            x_new[i] = original_value
    return x_new

# Метод для визуализации траектории (с измененным диапазоном)
def print_trajectory():
    print("\nВизуализация траектории:")
    grid = [['·' for _ in range(GRID_SIZE)] for _ in range(GRID_SIZE)]

    # Новый диапазон отображения (подходит для новой функции)
    min_x, max_x = -1.5, 1.5
    min_y, max_y = -1.5, 1.5

    # Рисуем траекторию
    for point in trajectory:
        x = int((point[0] - min_x) / (max_x - min_x) * (GRID_SIZE - 1))
        y = int((point[1] - min_y) / (max_y - min_y) * (GRID_SIZE - 1))
        x = min(max(x, 0), GRID_SIZE - 1)
        y = min(max(y, 0), GRID_SIZE - 1)
        grid[y][x] = '●'

    # Отмечаем известные локальные минимумы (примерные)
    min_x_pos1 = int((0.9 - min_x) / (max_x - min_x) * (GRID_SIZE - 1))
    min_y_pos1 = int((0.9 - min_y) / (max_y - min_y) * (GRID_SIZE - 1))
    grid[min_y_pos1][min_x_pos1] = '★'

    min_x_pos2 = int((-0.9 - min_x) / (max_x - min_x) * (GRID_SIZE - 1))
    min_y_pos2 = int((-0.9 - min_y) / (max_y - min_y) * (GRID_SIZE - 1))
    grid[min_y_pos2][min_x_pos2] = '★'

    # Выводим сетку с рамками
    print("┌" + "──" * GRID_SIZE + "┐")

    for row in grid:
        print("│" + " ".join(row) + " │")

    print("└" + "──" * GRID_SIZE + "┘")

    print("● - траектория  ★ - минимумы")

if __name__ == "__main__":
    main()
