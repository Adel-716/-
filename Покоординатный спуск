def f(x1, x2):
    """Целевая функция"""
    return x1 ** 4 - 2 * x1 * x2 + x2 ** 4 - x1 ** 2 - x2 ** 2


def print_ascii_map(trajectory, width=40, height=20):
    """Выводит ASCII-карту с траекторией поиска"""
    # Диапазон координат для отображения
    x_min, x_max = -1.5, 1.5
    y_min, y_max = -1.5, 1.5

    # Создаем пустую карту
    grid = [['·' for _ in range(width)] for _ in range(height)]

    # Отмечаем стационарные точки
    points = {
        (1, 1): 'M',  # Минимум
        (-1, -1): 'M',  # Минимум
        (0, 0): 'S'  # Седловая точка
    }

    for (x, y), symbol in points.items():
        col = int((x - x_min) / (x_max - x_min) * (width - 1))
        row = int((y_max - y) / (y_max - y_min) * (height - 1))  # Инвертируем y для корректного отображения
        if 0 <= row < height and 0 <= col < width:
            grid[row][col] = symbol

    # Отмечаем траекторию
    for i, (x, y) in enumerate(trajectory):
        col = int((x - x_min) / (x_max - x_min) * (width - 1))
        row = int((y_max - y) / (y_max - y_min) * (height - 1))
        if 0 <= row < height and 0 <= col < width:
            # Используем разные символы для разных этапов пути
            char = str(i % 10) if i < 10 else chr(ord('a') + (i - 10) % 26)
            if grid[row][col] == '·':  # Не перезаписываем стационарные точки
                grid[row][col] = char

    # Выводим карту
    print("+" + "-" * width + "+")
    for row in grid:
        print("|" + "".join(row) + "|")
    print("+" + "-" * width + "+")

    print("M - минимум (1,1) или (-1,-1)")
    print("S - седловая точка (0,0)")
    print("Цифры/буквы - траектория поиска (по порядку)")


def coordinate_search(x0, delta, epsilon=0.001, max_iter=100):
    """Метод покоординатного поиска с визуализацией"""
    x1, x2 = x0
    delta1, delta2 = delta
    trajectory = [(x1, x2)]  # Сохраняем траекторию

    for iteration in range(max_iter):
        # Исследующий поиск
        best_x1, best_x2 = x1, x2
        best_value = f(x1, x2)

        # Проверяем все возможные направления
        for dx1, dx2 in [(delta1, 0), (-delta1, 0), (0, delta2), (0, -delta2)]:
            new_x1 = x1 + dx1
            new_x2 = x2 + dx2
            new_value = f(new_x1, new_x2)

            if new_value < best_value:
                best_x1, best_x2 = new_x1, new_x2
                best_value = new_value

        # Проверка улучшения
        if best_value < f(x1, x2):
            # Ускоренный шаг
            x1 += 2 * (best_x1 - x1)
            x2 += 2 * (best_x2 - x2)
            trajectory.append((x1, x2))
        else:
            # Уменьшаем шаг
            delta1 /= 2
            delta2 /= 2
            # Критерий остановки
            if delta1 < epsilon and delta2 < epsilon:
                break

    return (x1, x2), f(x1, x2), trajectory


# Начальные параметры (попробуйте разные начальные точки)
start_points = [
    (0.5, 0.5),  # Сходится к (1,1)
    (-0.5, -0.5),  # Сходится к (-1,-1)
    (0.1, 0.1)  # Близко к седловой точке
]

for i, x0 in enumerate(start_points):
    delta = (0.2, 0.2)  # Начальный шаг

    print(f"\nПоиск #{i + 1} из начальной точки {x0}")
    result, f_value, trajectory = coordinate_search(x0, delta)

    # Вывод результатов
    print(f"Найденная точка: ({result[0]:.4f}, {result[1]:.4f})")
    print(f"Значение функции: {f_value:.4f}")
    print("Траектория поиска:")
    print_ascii_map(trajectory)
